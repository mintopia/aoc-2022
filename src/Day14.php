<?php

namespace Mintopia\Aoc2022;

use Mintopia\Aoc2022\Helpers\Result;

class Day14 extends Day
{
    protected const TITLE = 'Regolith Resevoir';
    protected const MATERIAL_SAND = 'sand';
    protected const MATERIAL_ROCK = 'rock';
    protected const SAND_SOURCE = [500, 0];

    protected array $cave;
    protected int $lowestPoint;

    protected bool $hasVisualisation = true;

    protected function loadData(): void
    {
        parent::loadData(); // TODO: Change the autogenerated stub
        $this->cave = $this->parseData();
        $this->lowestPoint = array_reduce($this->cave, function (int $carry, array $row): int {
            return max($carry, array_key_last($row));
        }, 0);
        if ($this->input->getOption('visualise')) {
            $this->io->title('Cave Layout');
            $this->renderCave($this->cave);
        }
    }

    protected function part1(): Result
    {
        $cave = $this->cave;
        $answer = 0;
        while ($this->addSand($cave, $this->lowestPoint + 1)) {
            $answer++;
        }
        if ($this->input->getOption('visualise')) {
            $this->renderCave($cave);
        }
        return new Result(Result::PART1, $answer);
    }

    protected function part2(Result $part1): Result
    {
        $cave = $this->cave;
        $cave = $this->addLine($cave, [498 - $this->lowestPoint, $this->lowestPoint + 2], [502 + $this->lowestPoint, $this->lowestPoint + 2]);
        $answer = 1;
        while ($this->addSand($cave, $this->lowestPoint + 2)) {
            $answer++;
        }
        if ($this->input->getOption('visualise')) {
            $this->renderCave($cave);
        }
        return new Result(Result::PART2, $answer);
    }

    protected function addSand(array &$cave, int $abyss): bool
    {
        [$x, $y] = self::SAND_SOURCE;

        while ($y < $abyss) {
            // Go down
            if (!isset($cave[$x][$y + 1])) {
                $y++;
                continue;
            }

            // or go down and left
            if (!isset($cave[$x - 1][$y + 1])) {
                $y++;
                $x--;
                continue;
            }

            // or go down and right
            if (!isset($cave[$x + 1][$y + 1])) {
                $y++;
                $x++;
                continue;
            }

            // Check if filled up
            if ([$x, $y] === self::SAND_SOURCE) {
                return false;
            }

            // We are at rest
            $cave[$x][$y] = self::MATERIAL_SAND;
            return true;
        }
        return false;
    }

    protected function parseData(): array
    {
        $cave = [];
        foreach ($this->data as $datum) {
            preg_match_all('/((?<x>\d+),(?<y>\d+))/', $datum, $matches);
            $points = [];
            foreach ($matches['x'] as $i => $xValue) {
                $yValue = $matches['y'][$i];
                $points[] = [$xValue, $yValue];
            }
            for ($i = 0; $i < count($points) - 1; $i++) {
                $cave = $this->addLine($cave, $points[$i], $points[$i + 1]);
            }
        }
        return $cave;
    }

    protected function addLine(array $cave, array $from, array $to): array
    {
        foreach (range($from[0], $to[0]) as $x) {
            if (!isset($cave[$x])) {
                $cave[$x] = [];
            }
            foreach (range($from[1], $to[1]) as $y) {
                $cave[$x][$y] = self::MATERIAL_ROCK;
            }
        }
        return $cave;
    }

    protected function renderCave(array $cave): void
    {
        // Get our bounds;
        $xMin = PHP_INT_MAX;
        $xMax = PHP_INT_MIN;
        $yMax = PHP_INT_MIN;
        foreach ($cave as $x => $row) {
            $xMin = min($xMin, $x - 2);
            $xMax = max($xMax, $x + 2);
            $keys = array_keys($row);
            sort($keys);
            $yMax = max($yMax, end($keys) + 2);
        }

        for ($y = 0; $y <= $yMax; $y++) {
            $line = '  ';
            for ($x = $xMin; $x <= $xMax; $x++) {
                if ([$x, $y] === self::SAND_SOURCE) {
                    $line .= '<fg=cyan>+</>';
                } elseif (!isset($cave[$x][$y])) {
                    $line .= ' ';
                } elseif ($cave[$x][$y] === self::MATERIAL_ROCK) {
                    $line .= 'â–ˆ';
                } elseif ($cave[$x][$y] === self::MATERIAL_SAND) {
                    $line .= '<fg=yellow>o</>';
                }
            }
            $this->output->writeln($line);
        }
    }
}