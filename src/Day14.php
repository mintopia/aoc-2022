<?php
namespace Mintopia\Aoc2022;

use Mintopia\Aoc2022\Helpers\Result;

class Day14 extends Day
{
    protected const MATERIAL_SAND = 'sand';
    protected const MATERIAL_ROCK = 'rock';
    protected const SAND_SOURCE = [500, 0];

    protected array $cave;
    protected int $lowestPoint;

    protected function loadData(): void
    {
        parent::loadData(); // TODO: Change the autogenerated stub
        $this->cave = $this->parseData();
        $this->lowestPoint = array_reduce($this->cave, function(int $carry, array $row): int {
                return max($carry, array_key_last($row));
            }, 0);
    }

    protected function part1(): Result
    {
        $cave = $this->cave;
        $answer = 0;
        while ($this->addSand($cave, null, $this->lowestPoint + 1)) {
            $answer++;
        }
        return new Result(Result::PART1, $answer);
    }

    protected function part2(Result $part1): Result
    {
        $cave = $this->cave;
        $answer = 1;
        while ($this->addSand($cave, $this->lowestPoint + 1)) {
            $answer++;
        }
        return new Result(Result::PART2, $answer);
    }

    protected function addSand(array &$cave, ?int $floor = null, ?int $abyss = null): bool
    {
        [$x, $y] = self::SAND_SOURCE;

        while (true) {
            // Check if abyss
            if ($abyss !== null && $y >= $abyss) {
                return false;
            }

            // Check if on floor
            if ($floor !== null && $y == $floor) {
                $cave[$x][$y] = self::MATERIAL_SAND;
                return true;
            }

            // Go down
            if (!isset($cave[$x][$y + 1])) {
                $y++;
                continue;
            }

            // or go down and left
            if (!isset($cave[$x - 1][$y + 1])) {
                $y++;
                $x--;
                continue;
            }

            // or go down and right
            if (!isset($cave[$x + 1][$y + 1])) {
                $y++;
                $x++;
                continue;
            }

            // Check if filled up
            if ([$x, $y] === self::SAND_SOURCE) {
                return false;
            }

            // We are at rest
            $cave[$x][$y] = self::MATERIAL_SAND;
            return true;
        }
    }

    protected function parseData(): array
    {
        $cave = [];
        foreach ($this->data as $datum) {
            preg_match_all('/((?<x>\d+),(?<y>\d+))/', $datum, $matches);
            $points = [];
            foreach ($matches['x'] as $i => $xValue) {
                $yValue = $matches['y'][$i];
                $points[] = [$xValue, $yValue];
            }
            for ($i = 0; $i < count($points) - 1; $i++) {
                $cave = $this->addLine($cave, $points[$i], $points[$i + 1]);
            }
        }
        return $cave;
    }

    protected function addLine(array $cave, array $from, array $to): array
    {
        foreach (range($from[0], $to[0]) as $x) {
            if (!isset($cave[$x])) {
                $cave[$x] = [];
            }
            foreach (range($from[1], $to[1]) as $y) {
                $cave[$x][$y] = self::MATERIAL_ROCK;
            }
        }
        return $cave;
    }
}